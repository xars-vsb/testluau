---------------------------------------------[[ setup ]]-------------------------------------------

local lib = loadstring("https://raw.githubusercontent.com/BRY402/random-scripts/main/stuff/lib.lua") --THANK U BRY!!!

-------------------------------------------[[ variables ]]-----------------------------------------

--local t1 = {
--	["leftleg"] = {
--		CFrame.new(-0.425, 1.401, -0.071),
--		CFrame.Angles(math.rad(32.224), math.rad(-153.269), math.rad(-17.062))
--	},
--	["rightleg"] = {
--		CFrame.new(0.5, 1.11, 0.477),F
--		CFrame.Angles(math.rad(9.006), math.rad(118.356), math.rad(-16.175))
--	},
--	["leftarm"] = {
--		CFrame.new(0.5, 0.5, 0),
--		CFrame.Angles(math.rad(25.145), math.rad(-46.163), math.rad(20.909))
--	},
--	["torso"] = {
--		CFrame.new(0.319, 0.132, -0.382),
--		CFrame.Angles(math.rad(-71.684), math.rad(-3.318), math.rad(144.857))
--	},
--	["head"] = {
--		CFrame.new(0, -0.5, 0),
--		CFrame.Angles(math.rad(-76.539), math.rad(-113.279), math.rad(-28.008))
--	},
--	["rightarm"] = {
--		CFrame.new(-0.654, 0.202, 0.04),
--		CFrame.Angles(math.rad(-2.57), math.rad(125.553), math.rad(-153.014))
--	}
--}

--local t2 = {
--	["leftleg"] = {
--		CFrame.new(-0.474, 1.463, 0.166),
--		CFrame.Angles(math.rad(7.706), math.rad(-76.059), math.rad(-28.377))
--	},
--	["rightleg"] = {
--		CFrame.new(0.5, 1, 0),
--		CFrame.Angles(math.rad(5.7), math.rad(118.266), math.rad(-1.997))
--	},
--	["leftarm"] = {
--		CFrame.new(0.456, 0.692, 0.017),
--		CFrame.Angles(math.rad(11.645), math.rad(-101.446), math.rad(-7.267))
--	},
--	["torso"] = {
--		CFrame.new(0.319, 0.132, -0.382),
--		CFrame.Angles(math.rad(-86.195), math.rad(0), math.rad(151.666))
--	},
--	["head"] = {
--		CFrame.new(0, -0.5, 0),
--		CFrame.Angles(math.rad(-72.511), math.rad(-21.65), math.rad(-117.107))
--	},
--	["rightarm"] = {
--		CFrame.new(-0.5, 0.5, 0),
--		CFrame.Angles(math.rad(-31.025), math.rad(52.764), math.rad(-175.055))
--	}
--}

local utilmodule = {}

function utilmodule.utils()
	return "utils, create, ls"
end

function utilmodule.weld(p1,p2)
	local _ = lib.Create("Weld",p1,{})
	_.Part0 = p1
	_.Part1 = p2

	return _
end

--function utilmodule.create(typ,properties)
--	assert(properties,"/> Properties table is invalid or nil. // utilutilmodulev1")
--	assert(typ,"/> Instance type is invalid or nil. // utilutilmodulev1")

--	local obj = lib.Create(typ,nil,{})

--	for _,property in pairs(properties) do
--		if not properties["Parent"] then obj.Parent = workspace end
--		if obj[tostring(_)] then
--			obj[tostring(_)] = property
--		end
--	end

--	return obj
--end

function utilmodule.ls(url)
	local s,e = pcall(function()
		loadstring(url)()
	end)

	assert(s,"/> Loadstring is not enabled, or your URL is invalid. (< "..e.." >) // utilutilmodulev1")
end

local sine = 0

local mode = 1
local movemode = 2

local sin,cos,rad,ran,floor,asin,exp = math.sin,math.cos,math.rad,math.random,math.floor,math.asin,math.exp
local gsub,gmatch,split,sub,len = string.gsub,string.gmatch,string.split,string.sub,string.len
local cf,angles,eulerXYZ = CFrame.new,CFrame.Angles,CFrame.fromEulerAnglesXYZ

local player = owner
local character = player.Character

local humanoid = character.Humanoid
local primary = character.PrimaryPart

local attack1cd,attack2cd = false,false

local ev = lib.Create("RemoteEvent",character,{}) 

NLS([[
local doo = game.Players.LocalPlayer.Character.RemoteEvent
local m = game.Players.LocalPlayer:GetMouse()

m.KeyDown:Connect(function(k)
	doo:FireServer(k)
end)
]],player.PlayerGui) --client

local Floor

local cwelds = {
	weldt = utilmodule.weld(character["Torso"],character["Left Arm"]),
	weldt1 = utilmodule.weld(character["Torso"],character["Right Arm"]),
	weldt2 = utilmodule.weld(character["Torso"],character["Left Leg"]),
	weldt3 = utilmodule.weld(character["Torso"],character["Right Leg"]),
	weldt4 = utilmodule.weld(character["Torso"],character["Head"]),
	weldt5 = utilmodule.weld(character["HumanoidRootPart"],character["Torso"]),
}

game:GetService("RunService").Heartbeat:Connect(function() -- movement detect
	Floor = humanoid.FloorMaterial
	if Floor == Enum.Material.Air then
		Floor = nil
	else
		Floor = true
	end
	local RootVelocity = (primary.Velocity * Vector3.new(1,0,1)).Magnitude
	if RootVelocity < 1 and Floor and movemode ~= 1 then
		movemode = 1
	elseif RootVelocity > 1 and Floor and movemode ~= 2 then
		movemode = 2
	end
end)

function destroyOnEnded(d)
	d.Ended:Connect(function() d:Destroy() end)
end

function effectp(limb,delay_)
	spawn(function()
		local newAt = script.t.effect:Clone()
		local magic1 = script.Magic1:Clone()
		local magic2 = script.Magic3:Clone()
		destroyOnEnded(magic1)
		destroyOnEnded(magic2)
		magic1.Parent = limb
		magic1:Play()
		task.wait(delay_)
		newAt.Parent = limb
		newAt.energy:Emit(1)
		newAt.explode:Emit(1)
		newAt["in"]:Emit(1)
		magic2.Parent = limb
		magic2:Play()
		task.wait(1)
		newAt:Destroy()
	end)
end

function effectp2(limb,delay_)
	spawn(function()
		local newAt = script.t.effect:Clone()
		local magic1 = script.Magic2:Clone()
		local magic2 = script.Magic4:Clone()
		local magic3 = script.Magic6:Clone()
		destroyOnEnded(magic1)
		destroyOnEnded(magic2)
		destroyOnEnded(magic3)
		magic1.Parent = limb
		magic1:Play()
		task.wait(delay_)
		newAt.Parent = limb
		newAt.energy:Emit(1)
		newAt.explode:Emit(1)
		newAt["in"]:Emit(1)
		magic2.Parent = limb
		magic2:Play()
		task.wait(0.2)
		magic3.Parent = limb
		magic3:Play()
		task.wait(0.8)
		newAt:Destroy()
	end)
end

function ring(p)
	local Ring = lib.Create("Part",script,{})
	Ring.Name = "Ring"
	Ring.Anchored = true
	Ring.BottomSurface = Enum.SurfaceType.Smooth
	Ring.CanCollide = false
	Ring.Transparency = 0.445
	Ring.TopSurface = Enum.SurfaceType.Smooth
	Ring.Color = Color3.fromRGB(17, 17, 17)
	Ring.Material = Enum.Material.Neon
	Ring.Size = Vector3.new(0.7214115858078003, 0.7214115858078003, 0.7214115858078003)
	Ring.Position = p.Position
	Ring.Orientation = Vector3.new(math.random(-360,360),math.random(-360,360),math.random(-360,360))
	local Mesh = lib.Create("SpecialMesh",Ring,{})
	Mesh.Scale = Vector3.new(0.00000000149011612, 0.007214121520519257, 0.00000000149011612)
	Mesh.MeshId = "rbxassetid://662585058"
	Mesh.MeshType = Enum.MeshType.FileMesh
	
	game:GetService("TweenService"):Create(Mesh,TweenInfo.new(0.3,Enum.EasingStyle.Sine,Enum.EasingDirection.In),{Scale = Vector3.new(0.12,0.006,0.12)}):Play()
	game:GetService("TweenService"):Create(Ring,TweenInfo.new(0.3,Enum.EasingStyle.Sine,Enum.EasingDirection.In),{Transparency = 1}):Play()
	
	spawn(function()
		task.wait(0.3)
		Ring:Destroy()
	end)
	
	spawn(function()
		while true do
			task.wait(0.01)
			if not Ring or not Mesh then
				break
			else
				Ring.CFrame = Ring.CFrame * eulerXYZ(0.05,0,0)
			end
		end
	end)
end

function explosion(limb,delay_,lines)
	spawn(function()
		task.wait(delay_)
		local newp = lib.Create("Part",script,{})
		newp.CanCollide = false
		newp.Anchored = true
		newp.Size = Vector3.new(0,0,0)
		newp.Position = limb.Position
		newp.Shape = Enum.PartType.Ball
		newp.Material = "Neon"
		newp.Color = Color3.fromRGB(88, 155, 255)
		newp.Touched:Connect(function(t)
			if t.Parent:FindFirstChild("Humanoid") and t.Parent ~= character then
				t.Parent.Humanoid.Health = -math.huge
			end
		end)
		spawn(function()
			for i = 1,10 do
				task.wait(0.015)
				ring(newp)
			end
		end)
		for i = 1,lines do
			spawn(function()
				local newp2 = lib.Create("Part",script,{})
				local newmesh = lib.Create("SpecialMesh",newp2,{})
				newp2.CanCollide = false
				newp2.Anchored = true
				newp2.Size = Vector3.new(0,0,0)
				newp2.Position = newp.Position
				newp2.Orientation = Vector3.new(math.random(-360,360),math.random(-360,360),math.random(-360,360))
				newp2.Material = "Neon"
				newp2.Color = Color3.fromRGB(88, 155, 255)
				newmesh.MeshType = Enum.MeshType.Sphere
				game:GetService("TweenService"):Create(newp2,TweenInfo.new(0.5,Enum.EasingStyle.Sine,Enum.EasingDirection.Out),{Size = Vector3.new(1,29,1),Transparency = 0.23}):Play()
				task.wait(0.5)
				game:GetService("TweenService"):Create(newp2,TweenInfo.new(0.6,Enum.EasingStyle.Sine,Enum.EasingDirection.In),{Size = Vector3.new(0,28,0),Transparency = 1}):Play()
				task.wait(0.6)
				newp2:Destroy()
			end)
		end
		game:GetService("TweenService"):Create(newp,TweenInfo.new(0.5,Enum.EasingStyle.Sine,Enum.EasingDirection.Out),{Size = Vector3.new(13,13,13),Transparency = 0.23}):Play()
		task.wait(0.5)
		game:GetService("TweenService"):Create(newp,TweenInfo.new(0.6,Enum.EasingStyle.Sine,Enum.EasingDirection.In),{Size = Vector3.new(12,12,12),Transparency = 1}):Play()
		task.wait(0.6)
		newp:Destroy()
	end)
end

function linesForward(p,amt,delay_)
	spawn(function()
		for i = 0,1,amt do
			task.wait(0.001)
			spawn(function()
				local magic1 = script.Magic7:Clone()
				local newp2 = lib.Create("Part",script,{})
				local newmesh = lib.Create("SpecialMesh",newp2,{})
				magic1.Parent = newp2
				newp2.CanCollide = false
				newp2.Anchored = true
				newp2.Size = Vector3.new(0.4,0.4,0.4)
				newp2.Position = p
				newp2.CFrame = newp2.CFrame:Lerp(cf(p)*cf(0,0,-15),i)
				newp2.Orientation = Vector3.new(math.random(-360,360),math.random(-360,360),math.random(-360,360))
				newp2.Material = "Neon"
				newp2.Color = Color3.fromRGB(88, 155, 255)
				newp2.Touched:Connect(function(t)
					if t.Parent:FindFirstChild("Humanoid") and t.Parent ~= character then
						t.Parent.Humanoid:TakeDamage(12)
					end
				end)
				newmesh.MeshType = Enum.MeshType.Sphere
				task.wait(delay_)
				for i = 1,3 do
					ring(newp2)
				end
				magic1:Play()
				game:GetService("TweenService"):Create(newp2,TweenInfo.new(0.25,Enum.EasingStyle.Sine,Enum.EasingDirection.Out),{Size = Vector3.new(0.2,29,0.2),Transparency = 0.23}):Play()
				task.wait(0.25)
				game:GetService("TweenService"):Create(newp2,TweenInfo.new(0.3,Enum.EasingStyle.Sine,Enum.EasingDirection.In),{Size = Vector3.new(0,28,0),Transparency = 1}):Play()
				task.wait(0.3)
				newp2:Destroy()
			end)
		end
	end)
end

function attack1()
	if not attack1cd then
		attack1cd = true
		mode = 2
		effectp(character["Left Leg"],0.2)
		for i = 0,1,0.05 do
			task.wait(0.001)
			cwelds["weldt5"].C0 = cwelds["weldt5"].C0:Lerp(cf(0,0,0)*angles(math.rad(-30),math.rad(15),0),i)
			cwelds["weldt"].C0 = cwelds["weldt"].C0:Lerp(cf(-1.5,0,0)*angles(math.rad(10),math.rad(-5),0),i)
			cwelds["weldt1"].C0 = cwelds["weldt1"].C0:Lerp(cf(1.5,0,0)*angles(math.rad(-10),math.rad(-5),0),i)
			cwelds["weldt2"].C0 = cwelds["weldt2"].C0:Lerp(cf(-0.5,-1.5,0)*angles(math.rad(-80),math.rad(-23),0),i)
			cwelds["weldt3"].C0 = cwelds["weldt3"].C0:Lerp(cf(0.5,-1.5,0)*angles(math.rad(5),math.rad(6),0),i)
		end
		spawn(function()
			task.wait(0.1)
			linesForward(character["Left Leg"].Position,0.02,0.3)
		end)
		for i = 0,1,0.1 do
			task.wait(0.001)
			cwelds["weldt5"].C0 = cwelds["weldt5"].C0:Lerp(cf(0,0,0.15)*angles(math.rad(30),math.rad(-40),0),i)
			cwelds["weldt"].C0 = cwelds["weldt"].C0:Lerp(cf(-1.5,0,0.4)*angles(math.rad(-50),math.rad(-5),0),i)
			cwelds["weldt1"].C0 = cwelds["weldt1"].C0:Lerp(cf(1.5,0,0.4)*angles(math.rad(-32),math.rad(-13),0),i)
			cwelds["weldt2"].C0 = cwelds["weldt2"].C0:Lerp(cf(-1.12,-1.5,-1)*angles(math.rad(50),math.rad(-23),math.rad(-43)),i)
			cwelds["weldt3"].C0 = cwelds["weldt3"].C0:Lerp(cf(0.52,-2.1,0.3)*angles(math.rad(-30),math.rad(6),0),i)
			cwelds["weldt4"].C0 = cwelds["weldt4"].C0:Lerp(cf(0,1.5,-0.12)*angles(math.rad(-30),math.rad(42),0),i)
		end
		mode = 1
		spawn(function()
			task.wait(2)
			attack1cd = false
		end)
	end
end
function attack2()
	if not attack2cd then
		attack2cd = true
		mode = 2
		effectp2(character["Right Leg"],0.3)
		for i = 0,1,0.05 do
			task.wait(0.001)
			cwelds["weldt5"].C0 = cwelds["weldt5"].C0:Lerp(cf(0,0,0)*angles(math.rad(30),math.rad(1),0),i)
			cwelds["weldt"].C0 = cwelds["weldt"].C0:Lerp(cf(-1.5,0,0)*angles(math.rad(-10),math.rad(18),0),i)
			cwelds["weldt1"].C0 = cwelds["weldt1"].C0:Lerp(cf(1.5,0,0)*angles(math.rad(-10),math.rad(15),0),i)
			cwelds["weldt2"].C0 = cwelds["weldt2"].C0:Lerp(cf(-0.5,-2,0)*angles(math.rad(-30),math.rad(9),0),i)
			cwelds["weldt3"].C0 = cwelds["weldt3"].C0:Lerp(cf(0.5,-0.7,-1.2)*angles(math.rad(30),math.rad(9),0),i)
			cwelds["weldt4"].C0 = cwelds["weldt4"].C0:Lerp(cf(0,1.5,-0.3)*angles(math.rad(-40),math.rad(3),0),i)
		end
		task.wait(0.1)
		explosion(character["Right Leg"],0.2,4)
		for i = 0,1,0.08 do
			task.wait(0.001)
			cwelds["weldt5"].C0 = cwelds["weldt5"].C0:Lerp(cf(0,0,0)*angles(math.rad(-30),math.rad(1),0),i)
			cwelds["weldt"].C0 = cwelds["weldt"].C0:Lerp(cf(-1.5,0.4,0)*angles(math.rad(-50),math.rad(-18),0),i)
			cwelds["weldt1"].C0 = cwelds["weldt1"].C0:Lerp(cf(1.5,0.4,0)*angles(math.rad(-50),math.rad(-15),0),i)
			cwelds["weldt2"].C0 = cwelds["weldt2"].C0:Lerp(cf(-0.5,-2,-0.5)*angles(math.rad(30),math.rad(-9),0),i)
			cwelds["weldt3"].C0 = cwelds["weldt3"].C0:Lerp(cf(0.5,-1.5,-1.3)*angles(math.rad(44),math.rad(12),0),i)
			cwelds["weldt4"].C0 = cwelds["weldt4"].C0:Lerp(cf(0,1.3,-0.3)*angles(math.rad(-60),math.rad(3),0),i)
		end

		task.wait(0.5)
		mode = 1
		spawn(function()
			task.wait(2)
			attack2cd = false
		end)
	end
end

game:GetService("RunService").Heartbeat:Connect(function()
	sine = sine + 1

	if mode == 1 then
		if movemode == 1 then
			cwelds["weldt5"].C0 = cwelds["weldt5"].C0:Lerp(cf(0,0,0.5)*cf(0,math.rad(0.5 + (math.sin((sine / 7) / 7) * 4 / 2)),0)*angles(math.rad(-5),math.rad(30),math.rad(5))*angles(math.rad(0.5 + (math.sin((sine / 7) / 7) * 4 / 2)),0,0),0.1)
			cwelds["weldt"].C0 = cwelds["weldt"].C0:Lerp(cf(-1.8,0,0)*cf(0,math.rad(0.5 + (math.sin((sine / 7) / 7) * -4 / 6)),0)*angles(math.rad(10),math.rad(0),math.rad(-30))*angles(math.rad(0.5 + (math.sin((sine / 7) / 7) * 4 / 2)),0,0),0.1)
			cwelds["weldt1"].C0 = cwelds["weldt1"].C0:Lerp(cf(1.8,0,0)*cf(0,math.rad(0.5 + (math.sin((sine / 7) / 7) * -4 / 6)),0)*angles(math.rad(-7),math.rad(0),math.rad(30))*angles(math.rad(0.5 + (math.sin((sine / 7) / 7) * 5 / 6)),0,0),0.1)
			cwelds["weldt2"].C0 = cwelds["weldt2"].C0:Lerp(cf(-0.5,-2,0.5)*cf(0,math.rad(0.5 + (math.sin((sine / 7) / 7) * -4 / 7)),0)*angles(math.rad(-30),math.rad(4),math.rad(2))*angles(math.rad(0.5 + (math.sin((sine / 7) / 7) * -8 / 7)),0,0),0.1)
			cwelds["weldt3"].C0 = cwelds["weldt3"].C0:Lerp(cf(0.5,-2,-0.5)*cf(0,math.rad(0.5 + (math.sin((sine / 7) / 7) * -4 / 7)),0)*angles(math.rad(-7),math.rad(-30),math.rad(-2))*angles(math.rad(0.5 + (math.sin((sine / 7) / 7) * -8 / 7)),0,0),0.1)
			cwelds["weldt4"].C0 = cwelds["weldt4"].C0:Lerp(cf(0,1.5,0)*cf(0,math.rad(0.5 + (math.sin((sine / 7) / 7) * -1 / 6)),0)*angles(math.rad(-2.5),math.rad(-30),math.rad(0))*angles(math.rad(0.5 + (math.sin((sine / 7) / 7) * 8 / 4)),0,0),0.1)
		elseif movemode == 2 then
			cwelds["weldt5"].C0 = cwelds["weldt5"].C0:Lerp(cf(0,0,0)*cf(0,math.rad(0.5 + (math.sin((sine / 4) / 5) * -4 / 2)),0)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(0,math.rad(0.5 + (math.sin((sine / 3) / 3) * -20 / 2)),0),0.1)
			cwelds["weldt"].C0 = cwelds["weldt"].C0:Lerp(cf(-1.6,0,0)*cf(0,math.rad(0.5 + (math.sin((sine / 3) / 3) * -4 / 2)),math.rad(0.5 + (math.sin((sine / 3) / 3) * -21 / 2)))*angles(math.rad(-0),math.rad(15),math.rad(2))*angles(math.rad(0.5 + (math.sin((sine / 3) / 3) * 30 / 2)),math.rad(0.5 + (math.sin((sine / 3) / 3) * -20 / 2)),0),0.1)
			cwelds["weldt1"].C0 = cwelds["weldt1"].C0:Lerp(cf(1.6,0,0)*cf(0,math.rad(0.5 + (math.sin((sine / 3) / 3) * -4 / 2)),math.rad(0.5 + (math.sin((sine / 3) / 3) * 21 / 2)))*angles(math.rad(0),math.rad(-15),math.rad(2))*angles(math.rad(0.5 + (math.sin((sine / 3) / 3) * -30 / 2)),math.rad(0.5 + (math.sin((sine / 3) / 3) * 20 / 2)),0),0.1)
			cwelds["weldt2"].C0 = cwelds["weldt2"].C0:Lerp(cf(-0.5,-2,0)*cf(0,math.rad(0.5 + (math.sin((sine / 3) / 3) * -4 / 2)),math.rad(math.sin((sine / 3) / 3) * 21 / 2))*angles(math.rad(-0),math.rad(4),math.rad(2))*angles(math.rad(0.5 + (math.sin((sine / 3) / 3) * -30 / 2)),math.rad(0.5 + (math.sin((sine / 3) / 3) * -20 / 2)),0),0.1)
			cwelds["weldt3"].C0 = cwelds["weldt3"].C0:Lerp(cf(0.5,-2,0)*cf(0,math.rad(0.5 + (math.sin((sine / 3) / 3) * -4 / 2)),math.rad(math.sin((sine / 3) / 3) * -21 / 2))*angles(math.rad(0),math.rad(-4),math.rad(-2))*angles(math.rad(0.5 + (math.sin((sine / 3) / 3) * 30 / 3)),math.rad(0.5 + (math.sin((sine / 3) / 3) * 20 / 2)),0),0.1)
			cwelds["weldt4"].C0 = cwelds["weldt4"].C0:Lerp(cf(0,1.5,0)*angles(math.rad(0),math.rad(4),math.rad(2))*angles(0,math.rad(0.5 + (math.sin((sine / 2.5) / 2.5) * 20 / 2)),0),0.1)
		end
	end
end)

ev.OnServerEvent:Connect(function(plr,k)
	if plr == player then
		if k == "z" then
			attack1()
		elseif k == "x" then
			attack2()
		end
	end
end)
